/**
 * Reply view queue for agent-generated drafts.
 * Displays ranked reply views generated by the heartbeat.
 */

import { ChannelInfo, ReplyView } from './shared'
import { renderApp } from './ui/App'
import { showPlatformSelector } from './ui/showPlatformSelector'
import { createPlatformClient } from '@/platforms/factory'
import {
  initDB,
  getClient,
  closeAllDBs,
} from './db'
import {
  loadReplyStore,
  rankReplyViews,
  removeReplyView,
  saveReplyStore,
} from './reply-store'

function formatPreview(text: string, maxLength: number): string {
  const cleaned = text.replace(/\s+/g, ' ').trim()
  if (cleaned.length <= maxLength) return cleaned
  return cleaned.slice(0, maxLength - 1) + '‚Ä¶'
}

function buildReplyQueue(replyViews: ReplyView[]): {
  channels: ChannelInfo[]
  displayItems: string[]
  displayIndexToChannelIndex: Map<number, number>
  replyViewsByChannel: Map<string, ReplyView[]>
} {
  const ranked = rankReplyViews(replyViews)
  const displayItems: string[] = []
  const channels: ChannelInfo[] = []
  const displayIndexToChannelIndex = new Map<number, number>()
  const replyViewsByChannel = new Map<string, ReplyView[]>()

  displayItems.push(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚ú® REPLY QUEUE (${ranked.length}) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`)

  let channelIndex = 0
  ranked.forEach((view, index) => {
    const rank = index + 1
    const channelId = `reply:${view.id}`
    const scoreLabel = view.interestingnessScore.toFixed(2)
    const preview = formatPreview(view.sourceContent, 60)
    const name = `${rank}. (${scoreLabel}) ${view.sourceAuthor}: ${preview}`
    channels.push({
      id: channelId,
      name,
      type: 'text',
      guildName: view.targetGuildName,
      guildId: undefined,
    })
    displayItems.push(name)
    displayIndexToChannelIndex.set(displayItems.length - 1, channelIndex)
    replyViewsByChannel.set(channelId, [view])
    channelIndex++
  })

  return { channels, displayItems, displayIndexToChannelIndex, replyViewsByChannel }
}

async function main() {
  try {
    const selectedPlatform = await showPlatformSelector()
    if (!selectedPlatform || selectedPlatform !== 'discord') {
      console.log('‚ùå This tool currently only supports Discord.')
      process.exit(0)
    }

    const realtimeDb = getClient('realtime', 'local')
    const archiveDb = getClient('archive', 'local')
    await initDB(realtimeDb)
    await initDB(archiveDb)

    console.log(`üîå Connecting to ${selectedPlatform}...`)
    const platformClient = await createPlatformClient(selectedPlatform)
    await platformClient.connect()
    console.log('‚úÖ Connected!')

    const store = loadReplyStore()
    let replyViews = store.replyViews
    let queue = buildReplyQueue(replyViews)

    const onRefreshChannels = async () => {
      const refreshedStore = loadReplyStore()
      replyViews = refreshedStore.replyViews
      queue = buildReplyQueue(replyViews)
      return {
        channels: queue.channels,
        displayItems: queue.displayItems,
        replyViewsByChannel: queue.replyViewsByChannel,
      }
    }

    const onRemoveReplyView = async (replyViewId: string) => {
      const refreshedStore = loadReplyStore()
      const updated = removeReplyView(refreshedStore, replyViewId)
      saveReplyStore(updated)
    }

    const getChannelFromDisplayIndex = (displayIndex: number): ChannelInfo | null => {
      const channelIdx = queue.displayIndexToChannelIndex.get(displayIndex)
      return channelIdx !== undefined ? queue.channels[channelIdx] : null
    }

    renderApp({
      client: platformClient,
      initialChannels: queue.channels,
      initialDisplayItems: queue.displayItems,
      title: `Reply Queue`,
      getMessagesForChannel: async () => [],
      getOlderMessagesForChannel: async () => ({ messages: [], newCount: 0, hasMore: false }),
      replyViewsByChannel: queue.replyViewsByChannel,
      getChannelFromDisplayIndex,
      onRefreshChannels,
      onRemoveReplyView,
      replyViewMode: true,
      onExit: async () => {
        await platformClient.disconnect()
        closeAllDBs()
      },
    })
  } catch (error) {
    console.error('‚ùå Error:', error instanceof Error ? error.message : 'Unknown error')
    process.exit(1)
  }
}

main()
